[cocos2dx_custom]
#prefix会被添加到生成的函数.你也可以选择不添加这个到你的模板
prefix = cocos2dx_custom

# 创建目标命名空间 (在 javascript里面， 这个会生成一些代码像： equiv. to `ns = ns || {}`)
# 所有的类都会嵌入到这个命名空间
target_namespace = 

android_headers = -I%(androidndkdir)s/platforms/android-14/arch-arm/usr/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/include
android_flags = -D_SIZE_T_DEFINED_ 

clang_headers = -I%(clangllvmdir)s/lib/clang/3.3/include 
clang_flags = -nostdinc -x c++ -std=c++11

cocos_headers = -I%(cocosdir)s/cocos -I%(cocosdir)s/custom -I%(cocosdir)s/cocos/base -I%(cocosdir)s/cocos/platform/android
cocos_flags = -DANDROID

cxxgenerator_headers = 

# 关于clang的额外内容
extra_arguments = %(android_headers)s %(clang_headers)s %(cxxgenerator_headers)s %(cocos_headers)s %(android_flags)s %(clang_flags)s %(cocos_flags)s %(extra_flags)s 

# 要解析的头文件
headers = %(cocosdir)s/cocos/custom/CustomClass.h

# 用来生成代码的类. 在这里，你可以使用正则表达式。在检测正则表达式的时候，它将会以"^$"结尾，就像这样 :"^Menu*$".
classes = CustomClass.* MaskSprite.*

# 我们应该跳过哪些内容?在这个格式里面 ClassName::[function function]
# ClassName是一个正则表达式，不过会像这样使用 : "^ClassName$" 函数也是
# 正则表达式，但它们不用 "^$"来表示边界。如果你想跳过整个类，只需要
# 添加一个单独的 "*" 作为函数。看下面的几个例子。  "*"是个特殊的类名，
# 表示所有的类。这是个十分方便的通配符，可以帮助我们跳过所有命名相似的函数，
# 无论它在哪个类

skip = 

rename_functions = 

rename_classes = 

#在目标虚拟机上面注册的时候，我们是不是应该为所有的类移除某些东西呢？
remove_prefix = 

# 没有父类的类
classes_have_no_parents = 

#当被它们的子类发现的时候会跳过的基类
base_classes_to_skip = 

#没有构造器的类
# 集合是特殊的，我们将会使用手写的构造器
abstract_classes = 

# 决定是否使用脚本对象(js 对象)来控制本地(cpp) 对象的生命周期或者相反的方向。 这里支持值为 'yes' 和 'no'.
script_control_cpp = no